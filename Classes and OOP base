======================================================================================================
Виды доступа внутри классов:
======================================================================================================

private - Работа с полями(переменными),функциями и всем остальным возможно только ВНУТРИ самого класса.
public  - Работа с полями(переменными),функциями и т.д возможна как и внутри калсса, так и за его пределами.
protected - Работа с полями(переменными),функцмями и всем остальным возможна как внутри класса, так и в Наследуемых классах.

======================================================================================================
Пример использования классов на примере Зданий и нескольких созданных сданий из одного класса (Пример сделан как принято делать правильно с Инкапсуляцией (когда все поля(переменные) пишутся в private без доступа к ним из вне))
======================================================================================================

class Building {
private:
    int year;
    string type;
    public:
        void set_data(int y, string t) {
            year = y;
            type = t;
        }

        void get_info() {
            cout << "type: " << type << " year: " << year << endl;
        }
};

int main()
{
    Building school;
    //school.type = "Shkola";
    //school.year = 2000;
    school.set_data(2000, "Shkola");
    school.get_info();
    
    Building Home;
    //Home.type = "Moya Konura";
    //Home.year = 1744;
    Home.set_data(1744, "Moya Konura");
    Home.get_info();

    return 0;
}

======================================================================================================
Пример улучшения предыдущего когда с помощью Конструктора + Еще и перегрузка методов внутри класса + Ещё и деструктор
======================================================================================================

class Building {
private:
    int year;
    string type;
    public:

        Building(int y, string t) {        //Конструктор, который позволит сократить код в main
            set_data(y, t);
        }
        
        Building() {}                      //Конструкторы внутри класса также можно перегуржать, что позволит как передавать параметры, так и не передавать их в main и это не будет вызывать ошибку

        Building(int y) {                 //Еще одна перегрузка, которая позволит добавлять только один параметр, при этом ошибки не будет
            year = y;
            cout << "Dannie ustanovleni" << endl;
        }

        void set_data(int y, string t) {
            year = y;
            type = t;
        }

        void set_data(int y) {             //И методы тоже внутри класса можно перегружать, если нам это надо или хочется    
            year = y;
        }


        void get_info() {
            cout << "type: " << type << " year: " << year << endl;
        }

        ~Building() {
            cout << "Delete object" << endl;       //Деструктор вызывается при удалении каждого объекта и выполняет код, тоесть здесь, он появится в конце выполнения программы и два раза напишет что объекты (Здания) удалены.
        }

};

int main()
{
    Building school(2000, "Shkola");       //Объект созданный в одну строку как раз благодаря конструктору в public и функции set_data к которой конструктор обращается
    school.get_info();
    
    Building Home(1744);                      //Новый объект с одним параметром, но ошибки нет, да еше и выдает текст из перегруженой функции, так как сработала именно она
    Home.get_info();

    return 0;

======================================================================================================
Указатель/Ключевое слово this ->
======================================================================================================

void set_data(int year, string type) {           //Здесь например указатель this нужен чтобы избежать конфликта имен, им мы указываем что бращаемся к полю которое есть в этом классе (которое записано в private) а второе это передаваемый параметр
    this->year = year;
    this->type = type;
}
